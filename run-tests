#!/bin/bash

# Testing Shell Kit

# Guiding Principles
#
#  - Tests are meant to look and act like bash code. Familiarity is key.
#  - Testing is as self-contained as possible, nothing to install on the host.
#  - Test output should contain enough information to see what went wrong.
#  - the API should be clean and readable; no need to use things named _ or tsk_.
#
# Tests are run with an empty writeable directory as the CWD. They
# are expected to leave this directory empty when they're finished,
# otherwise the test fails. TODO
#
# If your test produces output on stderr, make sure to check it,
# otherwise the test will fail. If you want to
# ignore stderr, you can do something like TODO: `stderr_matches .`
#

#: ## The Test Environment
#:
#: ### directories
#:
#: When a test is running, the current working directory is set
#: to an empty scratch directory. The test should make no assumption
#: about where this directory is stored; it might be in your project
#: directory, it might be in /tmp, and it might be on a magic ramdisk
#: somewhere.
#:
#: Your test can also access these directories:
#: - testfile_dir: The directory containing the testfile.
#:   For example, if you
#:   have some sample data in a file next to the testfile, you can
#:   specify it like this: `$(testfile_dir)/sample_data.txt`
#: - framework_dir: The directory containing the run-tests script.
#:   If you have a helper script in the same directory as the run-tests
#:   script, you can include it like this: `$(framework_dir)/helper.sh`
#:
#: ## The Testfile
#:
#: Testfiles start by including the test framework:
#:
#: ```bash
#: source "$(dirname "$0")/../run-tests.sh"
#: ```


# we reserve the tsk_ prefix to prevent incurring any conflicts
# with variables in the tests themselves. TODO: can we test if we
# accidentally leak any variables or non-api functions into the testfiles?

# Store the path to the run-tests.sh script for later use
tsk_framework_path="$(readlink -f "${BASH_SOURCE[0]}")"
tsk_testfile_path=""  # Will be set when a testfile sources this script

# Set the testfile path when this script is sourced
if [ "${BASH_SOURCE[1]}" != "" ]; then
    tsk_testfile_path="$(readlink -f "${BASH_SOURCE[1]}")"
fi

tsk_version="0.1"

# save the environment so it can be restored at the end
tsk_orig_cwd=""       # original directory before testing started
tsk_orig_path=""      # original PATH before testing started
exec 3>&1 4>&2        # copy stdout and stderr to FDs 3 and 4

tsk_total_count=0     # current number of tests run
tsk_pass_count=0      # current number of tests passed
tsk_fail_count=0      # current number of tests failed
tsk_root_dir=""       # main test directory
tsk_run_dir=""        # directory where tests run
tsk_artifacts_dir=""  # directory for temporary test artifacts

# these variables are reset every time a new test is run
tsk_test_name=""      # the name of the test currently being run
tsk_test_errors=0     # the number of errors
tsk_test_messages=""  # string containing a message for each error
tsk_stderr_checked=false # whether stderr has been explicitly checked

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# save stdout and stderr so we can restore them after testing
exec 3>&1 4>&2

pluralize() {
    local count=$1
    local singular=$2
    local plural=${3:-${singular}s}

    if [ "$count" -eq 1 ]; then
        echo "$singular"
    else
        echo "$plural"
    fi
}

# returns the line number of the caller of the given frame
# defaults to the caller of the function calling _line_number
_line_number() {
    local frame=${1:-1}
    local info=$(caller $frame)
    echo "${info%% *}"
}

# used to quote large content in the test output, like stderr
_blockquote() {
    echo -n "$1" | sed 's/^/    | /'
}

_add_error() {
    local message="$1"

    tsk_test_errors=$((tsk_test_errors + 1))
    if [ -n "$tsk_test_messages" ]; then
        tsk_test_messages="$tsk_test_messages"$'\n'
    fi
    tsk_test_messages="$tsk_test_messages  - $message"
}

_add_error_with_stderr() {
    _add_error "$@"
    local snippet="$(head -n 20 "$tsk_artifacts_dir/test-stderr")"
    tsk_test_messages="$tsk_test_messages"$'\n'"$(_blockquote "$snippet")"
}


_start_mocking() {
    local mock_dir="$tsk_artifacts_dir/test-mocks"
    mkdir -p "$mock_dir"
    export PATH="$mock_dir:$PATH"
}

mock() {
    local command="$1"
    local behavior="$2"
    local executable="$tsk_artifacts_dir/test-mocks/$command"
    cat > "$executable" << EOF
#!/bin/bash
$behavior
EOF
    chmod +x "$executable"
}

# at the end of the test, all mocks are removed
# TODO: one day we might want to set up mocks for multiple tests
_cleanup_mocks() {
    rm -rf "$tsk_artifacts_dir/test-mocks"/* "$tsk_artifacts_dir/test-mocks"/.*
}

_stop_mocking(){
    # no need to remove this dir from PATH because we're about to exit
    rmdir "$tsk_artifacts_dir/test-mocks"
    if [ $? -ne 0 ]; then
        echo "Internal error: mock dir wasn't empty?! This is a bug, I'M OUT" >&4
        exit 5
    fi
}


end_test() {
    _cleanup_mocks

    if [ -s "$tsk_artifacts_dir/test-stderr" ] && [ "$tsk_stderr_checked" = false ]; then
        _add_error_with_stderr "test produced stderr:"
    fi

    local res
    if [ "$tsk_total_count" -gt 0 ]; then
        if [ "$tsk_test_errors" -eq 0 ]; then
            tsk_pass_count=$((tsk_pass_count + 1))
            res="${GREEN}pass${NC}"
        else
            tsk_fail_count=$((tsk_fail_count + 1))
            res="${RED}FAIL${NC}"

            # Since the test failed, rename the run directory to preserve the state
            local safe_name=$(echo "$tsk_test_name" | tr ' /\\:*?"<>|' '_')
            local failed_dir="$tsk_root_dir/failed-$safe_name"
            mv "$tsk_run_dir" "$failed_dir"

            # Move artifacts to the failed test directory with clear names
            mkdir -p "$failed_dir"
            mv "$tsk_artifacts_dir/test-stdout" "$failed_dir/FAILED-stdout.txt" 2>&4
            mv "$tsk_artifacts_dir/test-stderr" "$failed_dir/FAILED-stderr.txt" 2>&4
            if [ -d "$tsk_artifacts_dir/test-mocks" ]; then
                mv "$tsk_artifacts_dir/test-mocks" "$failed_dir/FAILED-mocks" 2>&4
            fi
        fi

        local errmsg=''
        if [ $tsk_test_errors -gt 0 ]; then
            errmsg="($tsk_test_errors $(pluralize "$tsk_test_errors" "error"))"
        fi

        printf "\r %02d $res   $tsk_test_name $errmsg\n" "$tsk_total_count" >&3

        if [ -n "$tsk_test_messages" ]; then
            echo "$tsk_test_messages" >&3
        fi
    fi
}

ensure() {
    end_test  # if a test is already running, end it

    tsk_test_errors=0
    tsk_test_name="$1"
    tsk_stderr_checked=false
    tsk_total_count=$((tsk_total_count + 1))

    # Make sure artifacts directory exists
    mkdir -p "$tsk_artifacts_dir"

    # Redirect stdout and stderr to files in the artifacts directory
    exec 1>"$tsk_artifacts_dir/test-stdout" 2>"$tsk_artifacts_dir/test-stderr"

    # no newline, end_test will back up and print the result
    printf " %02d ....   $tsk_test_name" "$tsk_total_count" >&3
}

is_eq() {
    local expected=$1
    local actual=$2

    if [ "$expected" != "$actual" ]; then
        _add_error "line $(_line_number): is_eq expected '$expected', got '$actual'"
    fi
}

stderr_contains() {
    local expected_text="$1"

    tsk_stderr_checked=true
    if ! grep -q "$expected_text" "$tsk_artifacts_dir/test-stderr"; then
        _add_error_with_stderr "stderr_contains line $(_line_number): stderr doesn't contain: '$expected_text'"
    fi
}

# One trailing newline, if present, is trimmed from stdout before comparison.
# If you need to be pedantically correct about the presence of the final
# newline, you'll have to check for it outside of this function.
# TODO: this is not great.
stderr_is() {
    local expected_text="$1"
    local actual_text=$(cat "$tsk_artifacts_dir/test-stderr")

    echo -n "$expected_text" > /tmp/et
    echo -n "$actual_text" > /tmp/at

    tsk_stderr_checked=true
    if [ "$expected_text" != "$actual_text" ]; then
        local msg="stderr should have been: "$'\n'"$(_blockquote "$expected_text")"$'\n'"    but was:"
        _add_error_with_stderr "stderr_is line $(_line_number): $msg"
    fi
}

start_testing() {
    tsk_total_count=0
    tsk_pass_count=0
    tsk_fail_count=0

    tsk_test_name=""

    # TODO: ensure local directory is writeable first, bounce to /tmp if not
    # TODO: option to create and mount a ramdisk to run tests

    # Save current directory and PATH
    tsk_orig_cwd="$(pwd)"
    tsk_orig_path="$PATH"

    # Find an available test directory
    local dir_num=1
    while [ -e "tsk-test-$(printf "%02d" $dir_num)" ]; do
        dir_num=$((dir_num + 1))
        if [ $dir_num -gt 99 ]; then
            echo "Too many test directories. `rm -r tsk-test-*`" >&4
            exit 1
        fi
    done
    tsk_root_dir="tsk-test-$(printf "%02d" $dir_num)"
    tsk_run_dir="$tsk_root_dir/run"
    tsk_artifacts_dir="$tsk_root_dir/artifacts"

    mkdir -p "$tsk_run_dir" "$tsk_artifacts_dir"
    [ $? -ne 0 ] && exit 1   # error should already be printed

    # Change to the run directory
    cd "$tsk_run_dir"

    # Initialize artifacts files
    touch "$tsk_artifacts_dir/test-stdout" "$tsk_artifacts_dir/test-stderr"
    _start_mocking
}

# Returns the directory of the currently running testfile
testfile_dir() {
    if [ -z "$tsk_testfile_path" ]; then
        echo "Error: No testfile detected" >&2
        return 1
    fi
    dirname "$tsk_testfile_path"
}

# Returns the directory of the run-tests.sh script
framework_dir() {
    dirname "$tsk_framework_path"
}

stop_testing() {
    end_test
    _stop_mocking

    # Restore original stdout and stderr, etc
    exec 1>&3 2>&4
    export PATH="$tsk_orig_path"
    cd "$tsk_orig_cwd"

    local color="$YELLOW"
    if [ $tsk_fail_count -eq 0 ]; then
        color="$GREEN"
        # if all tests pass, there's no need to keep the test directory
        rm -rf "$tsk_root_dir"
    fi

    local count="${tsk_total_count} $(pluralize "$tsk_total_count" "test")"
    echo -e "${color}$count: ${tsk_pass_count} passed, ${tsk_fail_count} failed${NC}"
}
